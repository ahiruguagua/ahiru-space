<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Rubber Duck Shooter - ahiru-space.com</title>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TXQFE7EYKZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-TXQFE7EYKZ');
</script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800;900&family=Noto+Sans+JP:wght@400;700;900&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a3a5c;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  font-family: 'Nunito', 'Noto Sans JP', 'Courier New', monospace;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
}
canvas { display: block; border-radius: 12px; max-width: 100vw; max-height: 100vh; }
.back-link {
  position: fixed;
  top: 10px;
  left: 10px;
  color: rgba(255,255,255,0.6);
  text-decoration: none;
  font-size: 14px;
  font-weight: 700;
  z-index: 100;
  padding: 4px 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 20px;
}
.back-link:hover { color: #FFD700; }
#ui {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
}
#hud {
  width: 600px;
  display: flex;
  justify-content: space-between;
  padding: 12px 20px;
  color: #ffe066;
  font-size: 18px;
  font-weight: bold;
  text-shadow: 0 0 8px rgba(255,224,102,0.6);
  font-family: 'Courier New', monospace;
}
#overlay {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: #fff;
  pointer-events: auto;
  background: rgba(20,50,80,0.5);
  font-family: 'Courier New', monospace;
}
#overlay.hidden { display: none; pointer-events: none; }
#overlay h1 {
  font-size: 42px;
  color: #ffe066;
  text-shadow: 0 0 20px rgba(255,224,102,0.8), 0 2px 4px rgba(0,0,0,0.5);
  margin-bottom: 6px;
}
#overlay .subtitle {
  font-size: 16px;
  color: #8bcaff;
  margin-bottom: 20px;
}
#overlay button {
  padding: 14px 40px;
  font-size: 20px;
  font-family: 'Courier New', monospace;
  background: #ffe066;
  color: #1a3a5c;
  border: 3px solid #ffcc00;
  border-radius: 30px;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 3px;
  font-weight: bold;
  transition: all 0.2s;
  pointer-events: auto;
}
#overlay button:hover {
  background: #fff;
  box-shadow: 0 0 25px rgba(255,224,102,0.8);
  transform: scale(1.05);
}
#overlay .controls {
  margin-top: 25px;
  font-size: 14px;
  color: #8bcaff;
  text-align: center;
  line-height: 2;
}
#overlay .duck-preview {
  font-size: 64px;
  margin-bottom: 10px;
}
.touch-hint { display: none; }
@media (pointer: coarse) { .touch-hint { display: inline; color: #ffe066; } }

/* Game Over Overlay */
.gameover-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 80;
  background: rgba(0,0,0,0.7);
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}
.gameover-overlay.active { display: flex; }
.gameover-panel {
  background: rgba(10,20,40,0.95);
  border: 2px solid #ffe066;
  border-radius: 20px;
  padding: 2rem;
  max-width: 380px;
  width: 100%;
  text-align: center;
  font-family: 'Nunito', 'Noto Sans JP', sans-serif;
}
.gameover-panel h2 { color: #ff8866; font-size: 1.8rem; margin-bottom: 1rem; text-shadow: 0 0 15px rgba(255,136,102,0.6); }
.gameover-panel .stats { color: #fff; font-size: 1rem; line-height: 2; margin-bottom: 1rem; font-family: 'Courier New', monospace; }
.gameover-panel .stats span { color: #ffe066; font-weight: 800; }
.gameover-panel .highscore-entry { margin: 1rem 0; }
.gameover-panel .highscore-entry p { color: #ffe066; font-weight: 700; margin-bottom: 0.5rem; }
.gameover-panel input {
  width: 100%;
  padding: 10px 14px;
  border-radius: 10px;
  border: 2px solid rgba(255,224,102,0.4);
  background: rgba(255,255,255,0.1);
  color: #fff;
  font-size: 1rem;
  font-family: inherit;
  outline: none;
  margin-bottom: 0.5rem;
}
.gameover-panel input:focus { border-color: #ffe066; }
.gameover-panel input::placeholder { color: rgba(255,255,255,0.4); }
.go-btn {
  display: inline-block;
  padding: 10px 24px;
  border-radius: 50px;
  border: none;
  font-family: inherit;
  font-size: 1rem;
  font-weight: 800;
  cursor: pointer;
  margin: 6px;
  transition: transform 0.2s;
}
.go-btn:active { transform: scale(0.95); }
.go-btn.primary { background: #ffe066; color: #1a3a5c; }
.go-btn.primary:hover { background: #fff; }
.go-btn.secondary { background: rgba(255,255,255,0.15); color: #fff; border: 1px solid rgba(255,255,255,0.3); }
.go-btn.secondary:hover { background: rgba(255,255,255,0.25); }
.submitted-msg { color: #ffe066; font-weight: 700; margin: 0.5rem 0; }

/* Leaderboard Overlay */
.lb-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 90;
  background: rgba(0,0,0,0.8);
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}
.lb-overlay.active { display: flex; }
.lb-panel {
  background: rgba(10,20,40,0.97);
  border: 2px solid #ffe066;
  border-radius: 20px;
  padding: 1.5rem;
  max-width: 400px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
  font-family: 'Nunito', 'Noto Sans JP', sans-serif;
}
.lb-panel h2 { color: #ffe066; text-align: center; font-size: 1.4rem; margin-bottom: 1rem; }
.lb-row { display: flex; justify-content: space-between; padding: 6px 8px; color: rgba(255,255,255,0.8); font-size: 0.95rem; }
.lb-row.top3 { color: #ffe066; font-weight: 700; }
.lb-row .rank { width: 36px; }
.lb-row .name { flex: 1; }
.lb-row .score { text-align: right; }
.lb-empty { color: rgba(255,255,255,0.5); text-align: center; padding: 2rem; }
.lb-close { display: block; margin: 1rem auto 0; }

/* Touch Controls */
.touch-controls {
  display: none;
  position: fixed;
  bottom: 0; left: 0; right: 0;
  height: 200px;
  z-index: 50;
  pointer-events: none;
}
@media (pointer: coarse) {
  .touch-controls { display: flex; justify-content: space-between; align-items: flex-end; padding: 0 20px 24px; }
}
.joystick-zone {
  pointer-events: all;
  width: 140px;
  height: 140px;
  position: relative;
  -webkit-tap-highlight-color: transparent;
}
.joystick-base {
  width: 140px;
  height: 140px;
  border-radius: 50%;
  background: rgba(255,255,255,0.08);
  border: 2px solid rgba(255,255,255,0.2);
  position: absolute;
  top: 0; left: 0;
}
.joystick-knob {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: rgba(255,224,102,0.35);
  border: 2px solid rgba(255,224,102,0.6);
  position: absolute;
  top: 42px; left: 42px;
  transition: none;
}
.touch-slow-btn {
  pointer-events: all;
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background: rgba(255,255,255,0.12);
  border: 2px solid rgba(255,255,255,0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: 800;
  color: rgba(255,255,255,0.7);
  -webkit-tap-highlight-color: transparent;
  margin-bottom: 40px;
}
.touch-slow-btn.active {
  background: rgba(255,224,102,0.35);
  border-color: rgba(255,224,102,0.7);
  color: #ffe066;
}
</style>
</head>
<body>
<a href="/" class="back-link">&larr; Home</a>
<canvas id="game"></canvas>
<div id="ui">
  <div id="hud">
    <span id="scoreText">SCORE: 0</span>
    <span id="levelText">WAVE 1</span>
    <span id="livesText"></span>
  </div>
  <div id="overlay">
    <div class="duck-preview">üê§</div>
    <h1>RUBBER DUCK SHOOTER</h1>
    <div class="subtitle">~ bath time is battle time ~</div>
    <div class="controls">
      WASD / Áü¢Âç∞„Ç≠„Éº : Ê≥≥„Åê<br>
      Ëá™Âãï„Åß„Éê„Éñ„É´„Ç∑„Éß„ÉÉ„ÉàÁô∫Â∞ÑÔºÅ<br>
      SHIFT : „ÇÜ„Å£„Åè„ÇäÊ≥≥„Åê<br>
      <span class="touch-hint">„Çπ„Éû„Éõ: „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅßÊìç‰Ωú</span>
    </div>
    <br>
    <button id="startBtn">START</button>
  </div>
</div>

<!-- Game Over Overlay -->
<div class="gameover-overlay" id="gameoverOverlay">
  <div class="gameover-panel">
    <h2>GAME OVER</h2>
    <div class="stats">
      SCORE: <span id="goScore">0</span><br>
      WAVE: <span id="goWave">1</span>
    </div>
    <div class="highscore-entry" id="hsEntry" style="display:none;">
      <p>„É©„É≥„Ç≠„É≥„Ç∞ÂÖ•„ÇäÔºÅ „Å™„Åæ„Åà„ÇíÂÖ•Âäõ:</p>
      <input type="text" id="hsName" maxlength="15" placeholder="„Å™„Åæ„Åà" autocomplete="off">
      <button class="go-btn primary" id="hsSubmit">„Å®„ÅÜ„Çç„Åè</button>
    </div>
    <div class="submitted-msg" id="hsSubmitted" style="display:none;">„Å®„ÅÜ„Çç„Åè„Åó„Åæ„Åó„ÅüÔºÅ</div>
    <div>
      <button class="go-btn primary" id="goRestart">„ÇÇ„ÅÜ„ÅÑ„Å°„Å©</button>
      <button class="go-btn secondary" id="goLeaderboard">„É©„É≥„Ç≠„É≥„Ç∞</button>
    </div>
  </div>
</div>

<!-- Leaderboard Overlay -->
<div class="lb-overlay" id="lbOverlay">
  <div class="lb-panel">
    <h2>„É©„É≥„Ç≠„É≥„Ç∞ TOP 20</h2>
    <div id="lbList"></div>
    <button class="go-btn secondary lb-close" id="lbClose">„Å®„Åò„Çã</button>
  </div>
</div>

<!-- Touch Controls -->
<div class="touch-controls" id="touchControls">
  <div class="joystick-zone" id="joystickZone">
    <div class="joystick-base"></div>
    <div class="joystick-knob" id="joystickKnob"></div>
  </div>
  <div class="touch-slow-btn" id="btnSlow">SLOW</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 600, H = 800;
canvas.width = W;
canvas.height = H;

function resizeCanvas() {
  const ratio = W / H;
  let w = window.innerWidth, h = window.innerHeight;
  if (w / h > ratio) w = h * ratio; else h = w / ratio;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const scoreText = document.getElementById('scoreText');
const levelText = document.getElementById('levelText');
const livesText = document.getElementById('livesText');

const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Space') e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

let highScore = parseInt(localStorage.getItem('duckShooterHighScore') || '0');

// Audio
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playShoot() {
  try {
    const c = getAudioCtx(), o = c.createOscillator(), g = c.createGain();
    o.connect(g); g.connect(c.destination); o.type = 'sine';
    const n = c.currentTime;
    o.frequency.setValueAtTime(600, n);
    o.frequency.exponentialRampToValueAtTime(1200, n + 0.06);
    g.gain.setValueAtTime(0.12, n);
    g.gain.exponentialRampToValueAtTime(0.01, n + 0.08);
    o.start(n); o.stop(n + 0.08);
  } catch(e) {}
}

function playHit() {
  try {
    const c = getAudioCtx(), o = c.createOscillator(), g = c.createGain();
    o.connect(g); g.connect(c.destination); o.type = 'square';
    const n = c.currentTime;
    o.frequency.setValueAtTime(400, n);
    o.frequency.exponentialRampToValueAtTime(200, n + 0.06);
    g.gain.setValueAtTime(0.1, n);
    g.gain.exponentialRampToValueAtTime(0.01, n + 0.08);
    o.start(n); o.stop(n + 0.08);
  } catch(e) {}
}

function playDestroy() {
  try {
    const c = getAudioCtx(), n = c.currentTime;
    // Noise burst
    const buf = c.createBuffer(1, c.sampleRate * 0.15, c.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.max(0, 1 - i / data.length);
    const noise = c.createBufferSource();
    noise.buffer = buf;
    const gn = c.createGain();
    noise.connect(gn); gn.connect(c.destination);
    gn.gain.setValueAtTime(0.15, n);
    gn.gain.exponentialRampToValueAtTime(0.01, n + 0.15);
    noise.start(n); noise.stop(n + 0.15);
    // Falling tone
    const o = c.createOscillator(), g = c.createGain();
    o.connect(g); g.connect(c.destination); o.type = 'sine';
    o.frequency.setValueAtTime(500, n);
    o.frequency.exponentialRampToValueAtTime(100, n + 0.2);
    g.gain.setValueAtTime(0.12, n);
    g.gain.exponentialRampToValueAtTime(0.01, n + 0.2);
    o.start(n); o.stop(n + 0.2);
  } catch(e) {}
}

function playPowerup() {
  try {
    const c = getAudioCtx(), o = c.createOscillator(), g = c.createGain();
    o.connect(g); g.connect(c.destination); o.type = 'sine';
    const n = c.currentTime;
    o.frequency.setValueAtTime(400, n);
    o.frequency.exponentialRampToValueAtTime(1000, n + 0.15);
    g.gain.setValueAtTime(0.15, n);
    g.gain.exponentialRampToValueAtTime(0.01, n + 0.2);
    o.start(n); o.stop(n + 0.2);
  } catch(e) {}
}

function playDamage() {
  try {
    const c = getAudioCtx(), o = c.createOscillator(), g = c.createGain();
    o.connect(g); g.connect(c.destination); o.type = 'sawtooth';
    const n = c.currentTime;
    o.frequency.setValueAtTime(300, n);
    o.frequency.exponentialRampToValueAtTime(80, n + 0.2);
    g.gain.setValueAtTime(0.2, n);
    g.gain.exponentialRampToValueAtTime(0.01, n + 0.25);
    o.start(n); o.stop(n + 0.25);
  } catch(e) {}
}

function playGameOver() {
  try {
    const c = getAudioCtx(), n = c.currentTime;
    [200, 180, 150].forEach((f, i) => {
      const o = c.createOscillator(), g = c.createGain();
      o.connect(g); g.connect(c.destination); o.type = 'sine';
      o.frequency.setValueAtTime(f, n + i * 0.15);
      g.gain.setValueAtTime(0.2, n + i * 0.15);
      g.gain.exponentialRampToValueAtTime(0.01, n + i * 0.15 + 0.3);
      o.start(n + i * 0.15); o.stop(n + i * 0.15 + 0.3);
    });
  } catch(e) {}
}

function playWaveClear() {
  try {
    const c = getAudioCtx(), n = c.currentTime;
    [400, 500, 700].forEach((f, i) => {
      const o = c.createOscillator(), g = c.createGain();
      o.connect(g); g.connect(c.destination); o.type = 'sine';
      o.frequency.setValueAtTime(f, n + i * 0.12);
      g.gain.setValueAtTime(0.15, n + i * 0.12);
      g.gain.exponentialRampToValueAtTime(0.01, n + i * 0.12 + 0.25);
      o.start(n + i * 0.12); o.stop(n + i * 0.12 + 0.25);
    });
  } catch(e) {}
}

// Leaderboard
let leaderboard = [];
let scoreSubmitted = false;

async function fetchLeaderboard() {
  try {
    const res = await fetch('/api/shooter-scores');
    if (res.ok) leaderboard = await res.json();
  } catch(e) {}
}

async function submitScore(name, finalScore, finalWave) {
  try {
    const res = await fetch('/api/shooter-scores', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, score: finalScore, wave: finalWave })
    });
    if (res.ok) {
      leaderboard = await res.json();
      scoreSubmitted = true;
    }
  } catch(e) {}
}

function isHighScore(s) {
  if (leaderboard.length < 20) return s > 0;
  return s > leaderboard[leaderboard.length - 1].score;
}

function showLeaderboardOverlay() {
  const list = document.getElementById('lbList');
  if (leaderboard.length === 0) {
    list.innerHTML = '<div class="lb-empty">„Åæ„Å†„Çπ„Ç≥„Ç¢„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
  } else {
    list.innerHTML = leaderboard.slice(0, 20).map((e, i) => {
      const medal = i === 0 ? 'üëë' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i+1}.`;
      const waveText = e.wave ? ` W${e.wave}` : '';
      return `<div class="lb-row ${i < 3 ? 'top3' : ''}"><span class="rank">${medal}</span><span class="name">${e.name}</span><span class="score">${e.score.toLocaleString()}${waveText}</span></div>`;
    }).join('');
  }
  document.getElementById('lbOverlay').classList.add('active');
}

fetchLeaderboard();

// Game state
let player = null;
let bullets = [], enemies = [], enemyBullets = [], particles = [], powerups = [], floatTexts = [];
let score = 0, lives = 3, wave = 1, waveTimer = 0, gameState = 'title', shootCooldown = 0;
let bubbles = [];
let shakeTimer = 0, shakeIntensity = 0;
let waterOffset = 0;

function spawnFloatText(x, y, text, color) {
  floatTexts.push({ x, y, text, color, life: 60, maxLife: 60 });
}

function initBubbles() {
  bubbles = [];
  for (let i = 0; i < 60; i++) {
    bubbles.push({
      x: Math.random() * W,
      y: Math.random() * H,
      speed: 0.3 + Math.random() * 1.2,
      size: 2 + Math.random() * 6,
      wobble: Math.random() * Math.PI * 2,
      brightness: 0.15 + Math.random() * 0.25
    });
  }
}

function initGame() {
  player = { x: W / 2, y: H - 100, w: 40, h: 36, invincible: 0, power: 1, bobble: 0, barrier: 0, facing: -1 };
  bullets = [];
  enemies = [];
  enemyBullets = [];
  particles = [];
  powerups = [];
  floatTexts = [];
  score = 0;
  lives = 3;
  wave = 1;
  waveTimer = 0;
  shootCooldown = 0;
  gameState = 'playing';
  scoreSubmitted = false;
  overlay.classList.add('hidden');
  document.getElementById('gameoverOverlay').classList.remove('active');
  document.getElementById('lbOverlay').classList.remove('active');
  spawnWave();
}

function spawnWave() {
  const types = ['soap', 'sponge', 'loofah', 'showerhead'];
  const count = Math.min(24, 4 + wave * 3);
  for (let i = 0; i < count; i++) {
    const type = wave < 2 ? 'soap' : types[Math.floor(Math.random() * Math.min(wave, types.length))];
    enemies.push(createEnemy(type, i, count));
  }
}

function createEnemy(type, index) {
  const base = {
    x: 40 + (index % 8) * 65,
    y: -40 - Math.floor(index / 8) * 50,
    targetY: 60 + Math.floor(index / 8) * 55,
    w: 28, h: 28,
    type, shootTimer: Math.random() * 200,
    entering: true, flash: 0
  };
  switch (type) {
    case 'soap': return { ...base, hp: 1, maxHp: 1, speed: 1, color: '#b8e6b8', accent: '#7cc47c', score: 100, shootRate: Math.max(80, 250 - wave * 20) };
    case 'sponge': return { ...base, hp: 1, maxHp: 1, speed: 2 + wave * 0.3, color: '#ffcc66', accent: '#ee9933', score: 150, shootRate: Math.max(60, 180 - wave * 15), w: 24, h: 24 };
    case 'loofah': return { ...base, hp: 3 + wave, maxHp: 3 + wave, speed: 0.5 + wave * 0.1, color: '#d4a574', accent: '#b8865a', score: 300, shootRate: Math.max(80, 200 - wave * 15), w: 36, h: 36 };
    case 'showerhead': return { ...base, hp: 2 + Math.floor(wave / 2), maxHp: 2 + Math.floor(wave / 2), speed: 0.8 + wave * 0.15, color: '#c0c0c0', accent: '#888', score: 250, shootRate: Math.max(50, 150 - wave * 15), w: 28, h: 32 };
    default: return { ...base, hp: 1, maxHp: 1, speed: 1, color: '#b8e6b8', accent: '#7cc47c', score: 100, shootRate: 300 };
  }
}

function spawnParticles(x, y, color, count, speed) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const sp = Math.random() * speed;
    particles.push({
      x, y,
      vx: Math.cos(angle) * sp,
      vy: Math.sin(angle) * sp,
      life: 30 + Math.random() * 30,
      maxLife: 60,
      color,
      size: 1 + Math.random() * 3
    });
  }
}

function spawnSplash(x, y, count) {
  for (let i = 0; i < count; i++) {
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
    const sp = 2 + Math.random() * 4;
    particles.push({
      x, y,
      vx: Math.cos(angle) * sp,
      vy: Math.sin(angle) * sp - 2,
      life: 20 + Math.random() * 20,
      maxLife: 40,
      color: `hsl(200, 80%, ${70 + Math.random() * 30}%)`,
      size: 2 + Math.random() * 4,
      bubble: true
    });
  }
}

function shoot() {
  if (shootCooldown > 0) return;
  const p = player;
  const cd = p.power >= 3 ? 6 : p.power >= 2 ? 8 : 10;
  shootCooldown = cd;
  playShoot();
  bullets.push({ x: p.x, y: p.y - p.h / 2, vx: 0, vy: -8, size: 8, dmg: 1 });
  if (p.power >= 2) {
    bullets.push({ x: p.x - 14, y: p.y - p.h / 2 + 5, vx: -0.5, vy: -8, size: 6, dmg: 1 });
    bullets.push({ x: p.x + 14, y: p.y - p.h / 2 + 5, vx: 0.5, vy: -8, size: 6, dmg: 1 });
  }
  if (p.power >= 3) {
    bullets.push({ x: p.x - 24, y: p.y - p.h / 2 + 10, vx: -1.5, vy: -7, size: 6, dmg: 1 });
    bullets.push({ x: p.x + 24, y: p.y - p.h / 2 + 10, vx: 1.5, vy: -7, size: 6, dmg: 1 });
  }
}

function enemyShoot(e) {
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const baseSpd = e.type === 'showerhead' ? 5 : 3;
  const speed = baseSpd + wave * 0.3;
  enemyBullets.push({
    x: e.x, y: e.y + e.h / 2,
    vx: (dx / dist) * speed,
    vy: (dy / dist) * speed,
    size: e.type === 'showerhead' ? 5 : 6,
    color: e.type === 'showerhead' ? '#aaddff' : '#ff8866'
  });
}

function collides(a, b) {
  const aw = a.w || a.size * 2;
  const ah = a.h || a.size * 2;
  const bw = b.w || b.size * 2;
  const bh = b.h || b.size * 2;
  return Math.abs(a.x - b.x) < (aw + bw) / 2 && Math.abs(a.y - b.y) < (ah + bh) / 2;
}

function update() {
  waterOffset += 0.02;

  bubbles.forEach(b => {
    b.y -= b.speed;
    b.wobble += 0.02;
    b.x += Math.sin(b.wobble) * 0.3;
    if (b.y < -b.size) { b.y = H + b.size; b.x = Math.random() * W; }
  });

  if (gameState !== 'playing') return;

  player.bobble += 0.06;

  const slow = keys['ShiftLeft'] || keys['ShiftRight'] || touchSlow;
  const spd = slow ? 3 : 6;
  if (keys['ArrowLeft'] || keys['KeyA'] || touchDir.x < -0.3) { player.x -= spd * (keys['ArrowLeft'] || keys['KeyA'] ? 1 : Math.min(1, Math.abs(touchDir.x))); player.facing = 1; }
  if (keys['ArrowRight'] || keys['KeyD'] || touchDir.x > 0.3) { player.x += spd * (keys['ArrowRight'] || keys['KeyD'] ? 1 : Math.min(1, Math.abs(touchDir.x))); player.facing = -1; }
  if (keys['ArrowUp'] || keys['KeyW'] || touchDir.y < -0.3) player.y -= spd * (keys['ArrowUp'] || keys['KeyW'] ? 1 : Math.min(1, Math.abs(touchDir.y)));
  if (keys['ArrowDown'] || keys['KeyS'] || touchDir.y > 0.3) player.y += spd * (keys['ArrowDown'] || keys['KeyS'] ? 1 : Math.min(1, Math.abs(touchDir.y)));
  player.x = Math.max(player.w, Math.min(W - player.w, player.x));
  player.y = Math.max(player.h, Math.min(H - player.h, player.y));

  shoot();
  if (shootCooldown > 0) shootCooldown--;
  if (player.invincible > 0) player.invincible--;

  bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
  bullets = bullets.filter(b => b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20);

  enemyBullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
  enemyBullets = enemyBullets.filter(b => b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20);

  enemies.forEach(e => {
    if (e.entering) {
      e.y += 3;
      if (e.y >= e.targetY) { e.y = e.targetY; e.entering = false; }
    } else {
      if (e.type === 'sponge') e.x += Math.sin(Date.now() * 0.003 + e.targetY) * e.speed;
      e.y += Math.sin(Date.now() * 0.001 + e.x * 0.01) * 0.3;
    }
    if (e.flash > 0) e.flash--;
    e.shootTimer--;
    if (e.shootTimer <= 0 && !e.entering) {
      e.shootTimer = e.shootRate + Math.random() * 60;
      enemyShoot(e);
    }
  });

  bullets.forEach(b => {
    enemies.forEach(e => {
      if (collides(b, e)) {
        b.hit = true;
        e.hp -= b.dmg;
        e.flash = 6;
        spawnSplash(b.x, b.y, 5);
        if (e.hp <= 0) {
          playDestroy();
          e.dead = true;
          score += e.score;
          spawnSplash(e.x, e.y, 15);
          spawnParticles(e.x, e.y, e.color, 12, 4);
          shakeTimer = 6; shakeIntensity = 3;
          if (Math.random() < 0.18) {
            const r = Math.random();
            let type;
            if (r < 0.4) type = 'power';
            else if (r < 0.65) type = 'life';
            else if (r < 0.85) type = 'score';
            else type = 'barrier';
            powerups.push({ x: e.x, y: e.y, vy: 1.5, type, life: 400, w: 20, h: 20 });
          }
        } else {
          playHit();
        }
      }
    });
  });
  bullets = bullets.filter(b => !b.hit);
  enemies = enemies.filter(e => !e.dead);

  if (player.invincible <= 0) {
    enemyBullets.forEach(b => {
      if (collides(b, player)) {
        b.hit = true;
        lives--;
        playDamage();
        player.invincible = 120;
        player.power = Math.max(1, player.power - 1);
        shakeTimer = 15; shakeIntensity = 8;
        spawnSplash(player.x, player.y, 25);
        if (lives <= 0) gameOver();
      }
    });
    enemyBullets = enemyBullets.filter(b => !b.hit);

    enemies.forEach(e => {
      if (collides(e, player)) {
        lives--;
        playDamage();
        player.invincible = 120;
        player.power = Math.max(1, player.power - 1);
        e.dead = true;
        shakeTimer = 15; shakeIntensity = 8;
        spawnSplash(player.x, player.y, 25);
        spawnParticles(e.x, e.y, e.color, 10, 4);
        if (lives <= 0) gameOver();
      }
    });
    enemies = enemies.filter(e => !e.dead);
  } else if (player.barrier > 0) {
    enemyBullets.forEach(b => {
      if (collides(b, player)) {
        b.hit = true;
        spawnSplash(b.x, b.y, 5);
      }
    });
    enemyBullets = enemyBullets.filter(b => !b.hit);
  }

  if (player.barrier > 0) player.barrier--;

  powerups.forEach(p => {
    p.y += p.vy;
    p.life--;
    if (collides(p, player)) {
      p.collected = true;
      playPowerup();
      spawnSplash(player.x, player.y, 15);
      switch (p.type) {
        case 'power':
          player.power = Math.min(3, player.power + 1);
          spawnFloatText(p.x, p.y, 'POWER UP!', '#ff6');
          spawnParticles(p.x, p.y, '#ffe033', 15, 5);
          break;
        case 'life':
          lives = Math.min(5, lives + 1);
          spawnFloatText(p.x, p.y, 'LIFE +1', '#ff8888');
          spawnParticles(p.x, p.y, '#ff8888', 15, 5);
          break;
        case 'score':
          const bonus = 500 * wave;
          score += bonus;
          spawnFloatText(p.x, p.y, `+${bonus}pts`, '#88ffaa');
          spawnParticles(p.x, p.y, '#88ffaa', 15, 5);
          break;
        case 'barrier':
          player.barrier = 300;
          player.invincible = 300;
          spawnFloatText(p.x, p.y, 'BARRIER!', '#88ddff');
          spawnParticles(p.x, p.y, '#88ddff', 20, 6);
          break;
      }
    }
  });
  powerups = powerups.filter(p => !p.collected && p.life > 0 && p.y < H + 20);

  floatTexts.forEach(f => { f.y -= 1.2; f.life--; });
  floatTexts = floatTexts.filter(f => f.life > 0);

  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    if (p.bubble) p.vy += 0.05; else { p.vx *= 0.97; p.vy *= 0.97; }
    p.life--;
  });
  particles = particles.filter(p => p.life > 0);

  if (shakeTimer > 0) shakeTimer--;

  if (enemies.length === 0) {
    if (waveTimer === 0) playWaveClear();
    waveTimer++;
    if (waveTimer > 60) { wave++; waveTimer = 0; spawnWave(); }
  }

  scoreText.textContent = `SCORE: ${score}`;
  levelText.textContent = `WAVE ${wave}`;
  livesText.textContent = 'üê§'.repeat(lives);
}

function gameOver() {
  gameState = 'gameover';
  playGameOver();
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('duckShooterHighScore', String(highScore));
  }
  fetchLeaderboard().then(() => {
    document.getElementById('goScore').textContent = score.toLocaleString();
    document.getElementById('goWave').textContent = wave;
    document.getElementById('hsEntry').style.display = isHighScore(score) ? 'block' : 'none';
    document.getElementById('hsSubmitted').style.display = 'none';
    document.getElementById('hsName').value = '';
    document.getElementById('gameoverOverlay').classList.add('active');
  });
}

// ---- Drawing ----

function drawWater() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a4a7a');
  grad.addColorStop(0.5, '#1a5a8a');
  grad.addColorStop(1, '#0e3a5e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  ctx.globalAlpha = 0.04;
  for (let i = 0; i < 8; i++) {
    ctx.beginPath();
    ctx.strokeStyle = '#8ad4ff';
    ctx.lineWidth = 30 + i * 10;
    const yBase = 80 + i * 100;
    ctx.moveTo(-20, yBase);
    for (let x = 0; x <= W + 20; x += 20) {
      const y = yBase + Math.sin((x * 0.008) + waterOffset + i * 0.7) * 30;
      ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawBubbles() {
  bubbles.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(180,220,255,${b.brightness})`;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(b.x - b.size * 0.3, b.y - b.size * 0.3, b.size * 0.25, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${b.brightness * 0.8})`;
    ctx.fill();
  });
}

function drawDuck(x, y, size, bobble, facing) {
  ctx.save();
  ctx.translate(x, y);
  const bob = Math.sin(bobble) * 3;
  const tilt = Math.sin(bobble * 0.7) * 0.05;
  ctx.rotate(tilt);
  ctx.translate(0, bob);
  ctx.scale(facing, 1);

  const s = size / 40;

  ctx.strokeStyle = 'rgba(150,210,255,0.3)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 14 * s, 28 * s + Math.sin(bobble * 2) * 3, 5 * s, 0, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = '#f0c800';
  ctx.beginPath();
  ctx.moveTo(18 * s, 0);
  ctx.quadraticCurveTo(28 * s, -8 * s, 22 * s, -14 * s);
  ctx.quadraticCurveTo(20 * s, -6 * s, 16 * s, 2 * s);
  ctx.fill();

  ctx.fillStyle = '#ffe033';
  ctx.beginPath();
  ctx.ellipse(0, 6 * s, 22 * s, 18 * s, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#e6b800';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,240,180,0.6)';
  ctx.beginPath();
  ctx.ellipse(-5 * s, 0, 12 * s, 12 * s, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#f0c800';
  ctx.beginPath();
  ctx.ellipse(10 * s, 6 * s, 8 * s, 12 * s, 0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#ffe033';
  ctx.beginPath();
  ctx.arc(0, -16 * s, 14 * s, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#e6b800';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,240,180,0.5)';
  ctx.beginPath();
  ctx.arc(-3 * s, -19 * s, 7 * s, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.ellipse(-5 * s, -19 * s, 2.5 * s, 3 * s, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-5.8 * s, -20 * s, 1.2 * s, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#ff8c00';
  ctx.beginPath();
  ctx.moveTo(-12 * s, -15 * s);
  ctx.quadraticCurveTo(-20 * s, -13 * s, -12 * s, -10 * s);
  ctx.quadraticCurveTo(-6 * s, -12.5 * s, -12 * s, -15 * s);
  ctx.fill();
  ctx.strokeStyle = '#cc6600';
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.restore();
}

function drawPlayerBullet(b) {
  const grad = ctx.createRadialGradient(b.x - b.size * 0.2, b.y - b.size * 0.2, 0, b.x, b.y, b.size);
  grad.addColorStop(0, 'rgba(200,240,255,0.9)');
  grad.addColorStop(0.6, 'rgba(100,200,255,0.5)');
  grad.addColorStop(1, 'rgba(60,160,255,0.2)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = 'rgba(180,230,255,0.7)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.beginPath();
  ctx.arc(b.x - b.size * 0.3, b.y - b.size * 0.3, b.size * 0.25, 0, Math.PI * 2);
  ctx.fill();
}

function drawEnemyBullet(b) {
  if (b.color === '#aaddff') {
    ctx.fillStyle = 'rgba(150,210,255,0.8)';
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.arc(b.x - 1, b.y - 1, b.size * 0.3, 0, Math.PI * 2);
    ctx.fill();
  } else {
    ctx.fillStyle = b.color;
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);
  const color = e.flash > 0 ? '#fff' : e.color;
  const accent = e.flash > 0 ? '#ddd' : e.accent;

  if (e.type === 'soap') {
    const r = 6;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(-e.w / 2 + r, -e.h / 2);
    ctx.lineTo(e.w / 2 - r, -e.h / 2);
    ctx.quadraticCurveTo(e.w / 2, -e.h / 2, e.w / 2, -e.h / 2 + r);
    ctx.lineTo(e.w / 2, e.h / 2 - r);
    ctx.quadraticCurveTo(e.w / 2, e.h / 2, e.w / 2 - r, e.h / 2);
    ctx.lineTo(-e.w / 2 + r, e.h / 2);
    ctx.quadraticCurveTo(-e.w / 2, e.h / 2, -e.w / 2, e.h / 2 - r);
    ctx.lineTo(-e.w / 2, -e.h / 2 + r);
    ctx.quadraticCurveTo(-e.w / 2, -e.h / 2, -e.w / 2 + r, -e.h / 2);
    ctx.fill();
    ctx.strokeStyle = accent;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.arc(-4, -3, 3, 0, Math.PI * 2);
    ctx.arc(5, 2, 2, 0, Math.PI * 2);
    ctx.fill();
  } else if (e.type === 'sponge') {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, e.w / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = accent;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = accent;
    for (let i = 0; i < 5; i++) {
      const a = (i / 5) * Math.PI * 2;
      ctx.beginPath();
      ctx.arc(Math.cos(a) * 5, Math.sin(a) * 5, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  } else if (e.type === 'loofah') {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, e.w / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = accent;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.strokeStyle = accent;
    ctx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(-e.w / 2 + 4, -e.h / 2 + 8 + i * 10);
      ctx.lineTo(e.w / 2 - 4, -e.h / 2 + 8 + i * 10);
      ctx.stroke();
    }
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(-e.w / 2 + 8 + i * 10, -e.h / 2 + 4);
      ctx.lineTo(-e.w / 2 + 8 + i * 10, e.h / 2 - 4);
      ctx.stroke();
    }
    if (e.hp < e.maxHp) {
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(-e.w / 2, e.h / 2 + 5, e.w, 4);
      ctx.fillStyle = '#ff6644';
      ctx.fillRect(-e.w / 2, e.h / 2 + 5, e.w * (e.hp / e.maxHp), 4);
    }
  } else if (e.type === 'showerhead') {
    ctx.fillStyle = color;
    ctx.fillRect(-e.w / 2, -e.h / 2, e.w, e.h * 0.6);
    ctx.strokeStyle = accent;
    ctx.lineWidth = 2;
    ctx.strokeRect(-e.w / 2, -e.h / 2, e.w, e.h * 0.6);
    ctx.fillStyle = accent;
    ctx.fillRect(-3, -e.h / 2 + e.h * 0.6, 6, e.h * 0.4);
    ctx.fillStyle = '#6ab4e8';
    for (let r = 0; r < 2; r++) {
      for (let c = 0; c < 3; c++) {
        ctx.beginPath();
        ctx.arc(-8 + c * 8, -e.h / 2 + 6 + r * 8, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    if (e.hp < e.maxHp) {
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(-e.w / 2, e.h / 2 + 5, e.w, 4);
      ctx.fillStyle = '#ff6644';
      ctx.fillRect(-e.w / 2, e.h / 2 + 5, e.w * (e.hp / e.maxHp), 4);
    }
  }
  ctx.restore();
}

function drawMiniDuck(ox, oy) {
  ctx.fillStyle = '#ffe033';
  ctx.beginPath();
  ctx.ellipse(ox, oy + 2, 8, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(ox, oy - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ff8c00';
  ctx.beginPath();
  ctx.ellipse(ox - 5, oy - 4, 3, 1.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(ox - 1.5, oy - 6, 1.2, 0, Math.PI * 2);
  ctx.fill();
}

function drawPowerup(p) {
  ctx.save();
  ctx.translate(p.x, p.y);
  const pulse = 1 + Math.sin(Date.now() * 0.008) * 0.15;
  const bob = Math.sin(Date.now() * 0.004) * 3;
  ctx.translate(0, bob);
  ctx.scale(pulse, pulse);

  const glowColors = { power: '#ffe066', life: '#ff8888', score: '#88ffaa', barrier: '#88ddff' };
  const glowColor = glowColors[p.type] || '#ffe066';

  ctx.shadowColor = glowColor;
  ctx.shadowBlur = 18;
  ctx.strokeStyle = glowColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, 15, 0, Math.PI * 2);
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.arc(0, 0, 13, 0, Math.PI * 2);
  ctx.fill();

  if (p.type === 'power') {
    drawMiniDuck(0, 0);
  } else if (p.type === 'life') {
    ctx.fillStyle = '#ff6666';
    ctx.beginPath();
    ctx.moveTo(0, 4);
    ctx.bezierCurveTo(-8, -2, -8, -8, 0, -5);
    ctx.bezierCurveTo(8, -8, 8, -2, 0, 4);
    ctx.fill();
  } else if (p.type === 'score') {
    ctx.fillStyle = '#88ffaa';
    ctx.font = 'bold 16px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('$', 0, 0);
  } else if (p.type === 'barrier') {
    ctx.strokeStyle = '#88ddff';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(0, -9);
    ctx.lineTo(-8, -5);
    ctx.lineTo(-8, 3);
    ctx.quadraticCurveTo(0, 11, 0, 11);
    ctx.quadraticCurveTo(0, 11, 8, 3);
    ctx.lineTo(8, -5);
    ctx.closePath();
    ctx.stroke();
    ctx.fillStyle = 'rgba(136,221,255,0.3)';
    ctx.fill();
  }

  ctx.restore();
}

function draw() {
  ctx.save();

  if (shakeTimer > 0) {
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
  }

  drawWater();
  drawBubbles();

  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    if (p.bubble) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = `rgba(200,230,255,${alpha * 0.3})`;
      ctx.fill();
    } else {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  ctx.globalAlpha = 1;

  bullets.forEach(b => drawPlayerBullet(b));
  enemyBullets.forEach(b => drawEnemyBullet(b));
  enemies.forEach(e => drawEnemy(e));
  powerups.forEach(p => drawPowerup(p));

  if (gameState === 'playing' && player) {
    if (player.barrier > 0) {
      const ba = Math.min(1, player.barrier / 30);
      ctx.strokeStyle = `rgba(100,200,255,${ba * 0.6})`;
      ctx.lineWidth = 3;
      ctx.shadowColor = '#88ddff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(player.x, player.y, 30 + Math.sin(Date.now() * 0.01) * 3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    if (!(player.invincible > 0 && player.barrier <= 0 && Math.floor(player.invincible / 4) % 2)) {
      drawDuck(player.x, player.y, 40, player.bobble, player.facing);
    }
  }

  floatTexts.forEach(f => {
    const alpha = f.life / f.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = f.color;
    ctx.font = 'bold 18px Courier New';
    ctx.textAlign = 'center';
    ctx.shadowColor = f.color;
    ctx.shadowBlur = 10;
    ctx.fillText(f.text, f.x, f.y);
    ctx.shadowBlur = 0;
  });
  ctx.globalAlpha = 1;

  if (gameState === 'playing' && enemies.length === 0 && waveTimer > 0 && waveTimer < 60) {
    ctx.fillStyle = '#ffe066';
    ctx.font = 'bold 32px Courier New';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(255,224,102,0.8)';
    ctx.shadowBlur = 15;
    ctx.fillText(`WAVE ${wave} CLEAR!`, W / 2, H / 2);
    ctx.shadowBlur = 0;
  }

  ctx.restore();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// --- HTML Overlay Button Handlers ---
startBtn.addEventListener('click', initGame);

document.getElementById('goRestart').addEventListener('click', () => {
  initGame();
});

document.getElementById('goLeaderboard').addEventListener('click', () => {
  showLeaderboardOverlay();
});

document.getElementById('hsSubmit').addEventListener('click', async () => {
  const nameEl = document.getElementById('hsName');
  const name = nameEl.value.trim();
  if (name.length > 0 && !scoreSubmitted) {
    await submitScore(name, score, wave);
    document.getElementById('hsEntry').style.display = 'none';
    document.getElementById('hsSubmitted').style.display = 'block';
  }
});

document.getElementById('lbClose').addEventListener('click', () => {
  document.getElementById('lbOverlay').classList.remove('active');
});

document.getElementById('hsName').addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    document.getElementById('hsSubmit').click();
  }
});

document.addEventListener('keydown', e => {
  if (gameState !== 'gameover') return;
  if (document.activeElement === document.getElementById('hsName')) return;
  if (e.code === 'KeyR') initGame();
  if (e.code === 'KeyL') showLeaderboardOverlay();
  if (e.code === 'Escape') document.getElementById('lbOverlay').classList.remove('active');
});

// --- Touch Controls ---
const touchDir = { x: 0, y: 0 };
let touchSlow = false;
let joystickTouchId = null;

const joystickZone = document.getElementById('joystickZone');
const joystickKnob = document.getElementById('joystickKnob');
const btnSlow = document.getElementById('btnSlow');
const touchControls = document.getElementById('touchControls');

const JOYSTICK_RADIUS = 70; // half of 140
const KNOB_MAX = 42; // max knob travel from center

function handleJoystick(touch) {
  const rect = joystickZone.getBoundingClientRect();
  const cx = rect.left + JOYSTICK_RADIUS;
  const cy = rect.top + JOYSTICK_RADIUS;
  let dx = touch.clientX - cx;
  let dy = touch.clientY - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > JOYSTICK_RADIUS) {
    dx = (dx / dist) * JOYSTICK_RADIUS;
    dy = (dy / dist) * JOYSTICK_RADIUS;
  }
  touchDir.x = dx / JOYSTICK_RADIUS;
  touchDir.y = dy / JOYSTICK_RADIUS;
  const knobX = (dx / JOYSTICK_RADIUS) * KNOB_MAX;
  const knobY = (dy / JOYSTICK_RADIUS) * KNOB_MAX;
  joystickKnob.style.left = (42 + knobX) + 'px';
  joystickKnob.style.top = (42 + knobY) + 'px';
}

function resetJoystick() {
  touchDir.x = 0;
  touchDir.y = 0;
  joystickKnob.style.left = '42px';
  joystickKnob.style.top = '42px';
  joystickTouchId = null;
}

joystickZone.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  joystickTouchId = t.identifier;
  handleJoystick(t);
}, { passive: false });

joystickZone.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === joystickTouchId) { handleJoystick(t); break; }
  }
}, { passive: false });

joystickZone.addEventListener('touchend', e => {
  for (const t of e.changedTouches) {
    if (t.identifier === joystickTouchId) { resetJoystick(); break; }
  }
}, { passive: false });

joystickZone.addEventListener('touchcancel', e => {
  for (const t of e.changedTouches) {
    if (t.identifier === joystickTouchId) { resetJoystick(); break; }
  }
}, { passive: false });

btnSlow.addEventListener('touchstart', e => {
  e.preventDefault();
  touchSlow = true;
  btnSlow.classList.add('active');
}, { passive: false });
btnSlow.addEventListener('touchend', e => {
  e.preventDefault();
  touchSlow = false;
  btnSlow.classList.remove('active');
}, { passive: false });
btnSlow.addEventListener('touchcancel', e => {
  touchSlow = false;
  btnSlow.classList.remove('active');
}, { passive: false });

// Tap canvas to start from title on mobile
canvas.addEventListener('touchstart', e => {
  if (gameState === 'title') { initGame(); e.preventDefault(); }
}, { passive: false });

// Hide touch controls on game over
const origGameOver = gameOver;

initBubbles();
loop();
</script>
</body>
</html>
